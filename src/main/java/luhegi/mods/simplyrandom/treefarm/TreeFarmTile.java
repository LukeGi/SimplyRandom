package luhegi.mods.simplyrandom.treefarm;

import luhegi.mods.simplyrandom.SimplyRandom;
import luhegi.mods.simplyrandom.basis.objects.BasisTile;
import luhegi.mods.simplyrandom.basis.objects.FakeWorld;
import luhegi.mods.simplyrandom.basis.tile.BasisEnergyStorage;
import luhegi.mods.simplyrandom.basis.tile.BasisItemHandler;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.SaplingBlock;
import net.minecraft.block.trees.Tree;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.CompoundNBT;
import net.minecraft.nbt.ListNBT;
import net.minecraft.nbt.LongNBT;
import net.minecraft.nbt.NBTUtil;
import net.minecraft.tileentity.ITickableTileEntity;
import net.minecraft.util.NonNullList;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.server.ServerWorld;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.common.util.Constants;
import net.minecraftforge.event.world.SaplingGrowTreeEvent;
import net.minecraftforge.eventbus.api.Event;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.items.ItemHandlerHelper;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Sit and wait for growth event
 * When a growth event occurs, harvest the tree and store it in the pocket dimension.
 * Store the position and state of each grown block
 * Use the state and position to spawn block break particles in the real world at the same position.
 * Use the data generated by the fake world to create drops and spawn particles as the blocks are harvested.
 * Make the machine take time relative to hardness of the block to break said block.
 * Add a GUI to show the inventory's contents.
 * Make the block require energy to break the blocks, relative to hardness
 * Make the
 */
public class TreeFarmTile extends BasisTile<TreeFarmTile> implements ITickableTileEntity {
    private static final Logger LOGGER = LogManager.getLogger(TreeFarmTile.class);
    private final BasisItemHandler inventory = new BasisItemHandler(72);
    private final BasisEnergyStorage battery = new BasisEnergyStorage(TreeFarm.getMaxStorage());
    private final List<Pair<BlockPos, BlockState>> harvestedBlocks = new ArrayList<>();
    private final NonNullList<ItemStack> currentDrops = NonNullList.create();
    private FakeWorld pocketDimension;
    private float nextWorkTick = 0;

    public TreeFarmTile() {
        super(TreeFarm.INSTANCE.TILE_TYPE);
        addCap(inventory);
        addCap(battery);
    }

    @Override
    public void tick() {
        if (!(world instanceof ServerWorld) || harvestedBlocks.isEmpty() || (battery.isEmpty() && TreeFarm.getUseEnergy())) return;
        while (!currentDrops.isEmpty()) {
            ItemStack drop = currentDrops.remove(0);
            ItemStack leftOver = ItemHandlerHelper.insertItem(inventory, drop, false);
            if (!leftOver.isEmpty()) {
                currentDrops.add(leftOver);
                break;
            }
        }
        if (nextWorkTick > 0) {
            nextWorkTick--;
            return;
        }
        while (currentDrops.isEmpty() && !harvestedBlocks.isEmpty()) {
            Pair<BlockPos, BlockState> remove = harvestedBlocks.remove(0);
            BlockPos pos = remove.getKey();
            BlockState state = remove.getValue();
            spawnParticles(pos, state);
            currentDrops.addAll(getDrops(state, pos));
            nextWorkTick += state.getBlockHardness(world, pos) * 10f;
        }
        consumeEnergy((int) Math.floor(nextWorkTick));
    }

    private void consumeEnergy(int amount) {
        battery.use(amount * TreeFarm.getEnergyPerWork());
    }

    private List<ItemStack> getDrops(BlockState state, BlockPos pos) {
        return Block.getDrops(state, (ServerWorld) world, pos, null);
    }

    private void spawnParticles(BlockPos pos, BlockState state) {
        world.playEvent(2001, pos, Block.getStateId(state));
    }

    @Override
    public void onLoad() {
        MinecraftForge.EVENT_BUS.register(this);
    }

    @Override
    public void onChunkUnloaded() {
        MinecraftForge.EVENT_BUS.unregister(this);
    }

    @SubscribeEvent
    public void onTreeGrow(final SaplingGrowTreeEvent event) {
        if (!(getWorld() instanceof ServerWorld)) {
            return;
        }
        if (!event.getPos().withinDistance(getPos(), 6)) {
            return;
        }
        event.setResult(Event.Result.DENY);

        getWorld().getProfiler().startSection(SimplyRandom.ID + ":tree_farm");
        BlockState sapling = getWorld().getBlockState(event.getPos());
        growTree(sapling, event.getPos(), event.getRand());
        getWorld().setBlockState(event.getPos(), sapling.cycle(SaplingBlock.STAGE), 4);
        getWorld().getProfiler().endStartSection(SimplyRandom.ID + ":tree_farm");
    }

    private void growTree(BlockState sapling, BlockPos pos, Random rand) {
        Block block = sapling.getBlock();
        Tree tree = null;
        try {
            Field treeField = block.getClass().getDeclaredField("tree");
            treeField.setAccessible(true);
            tree = (Tree) treeField.get(block);
        } catch (IllegalAccessException | NoSuchFieldException e) {
            LOGGER.error(SimplyRandom.LOG_MARKER, "Error occurred when attempting to get the tree of a sapling.", e);
        }
        if (tree == null) {
            return;
        }
        ServerWorld world = (ServerWorld) getWorld();
        FakeWorld fakeWorld = getFakeWorld();
        fakeWorld.reset();
        fakeWorld.setBlockState(pos, sapling.with(SaplingBlock.STAGE, 1), 4);
        tree.place(fakeWorld, world.getChunkProvider().generator, pos, sapling, rand);
        harvestDrops(fakeWorld);
    }

    private void harvestDrops(FakeWorld world) {
        harvestedBlocks.addAll(world.getTree());
    }

    private FakeWorld getFakeWorld() {
        if (!(world instanceof ServerWorld))
            throw new IllegalStateException("Attempted to get the fake world on the client... Fix this.");
        if (pocketDimension == null) {
            pocketDimension = new FakeWorld((ServerWorld) world);
        }
        return pocketDimension;
    }

    @Override
    public CompoundNBT write(CompoundNBT compound) {
        ListNBT posList = new ListNBT();
        ListNBT stateList = new ListNBT();
        for (int i = 0; i < harvestedBlocks.size(); i++) {
            Pair<BlockPos, BlockState> pair = harvestedBlocks.get(i);
            posList.add(i, LongNBT.valueOf(pair.getKey().toLong()));
            stateList.add(i, NBTUtil.writeBlockState(pair.getValue()));
        }
        compound.put("posList", posList);
        compound.put("stateList", stateList);
        return super.write(compound);
    }

    @Override
    public void read(CompoundNBT compound) {
        if (compound.contains("posList") && compound.contains("stateList")) {
            harvestedBlocks.clear();
            ListNBT posList = compound.getList("posList", Constants.NBT.TAG_LONG);
            ListNBT stateList = compound.getList("stateList", Constants.NBT.TAG_COMPOUND);
            for (int i = 0; i < posList.size(); i++) {
                BlockPos pos = BlockPos.fromLong(((LongNBT) posList.get(i)).getLong());
                BlockState state = NBTUtil.readBlockState(stateList.getCompound(i));
                harvestedBlocks.add(Pair.of(pos, state));
            }
        }
        super.read(compound);
    }
}
